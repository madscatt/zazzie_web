#!/share/apps/local/bin/python/bin/python
import json,sys,os,shutil,locale
from StringIO import StringIO
import multiprocessing,time,string,socket

import sassie.simulate.monte_carlo.complex.nmer_dihedral as nmer_dihedral
import sassie.interface.input_filter as input_filter
import sassie.interface.complex_filter as complex_filter

class CGenerate_Drv():

   module = 'complex_monte_carlo'

   def message_box(self,text,icon):

        _message = {}
        _message['icon'] = icon
        _message['text'] = text

        UDP_IP = json_variables['_udphost']
        UDP_PORT = json_variables['_udpport']
        sock = socket.socket(socket.AF_INET, # Internet
                socket.SOCK_DGRAM) # UDP

        socket_dict={}
        socket_dict['_uuid'] = json_variables['_uuid']
        socket_dict['_message'] = _message

        doc_string = json.dumps(socket_dict)
        sock.sendto(doc_string,(UDP_IP,UDP_PORT))

        return

   def background_job(self,process,txtQueue,json_variables):

        total_string = ''

        UDP_IP = json_variables['_udphost']
        UDP_PORT = json_variables['_udpport']
        sock = socket.socket(socket.AF_INET, # Internet
                socket.SOCK_DGRAM) # UDP

        socket_dict={}
        socket_dict['_uuid'] = json_variables['_uuid']
	first = True

        while process.is_alive():
                try:
                        if(first):
                                socket_dict['progress_html'] = '<center>starting job</center>'
                                socket_dict['_progress'] = 0.01
                                doc_string = json.dumps(socket_dict)
                                sock.sendto(doc_string,(UDP_IP,UDP_PORT))
                                first = False
                        this_text = txtQueue.get(True, timeout=0.01)
                        text_split=string.split(this_text)
                        if(text_split[0]=='STATUS'):
                                value = locale.atof(text_split[1])
                                svalue = str(round(100*value,2))
                                socket_dict['progress_output'] = value
                                socket_dict['_progress'] = value
                                socket_dict['progress_html'] = '<center>'+svalue+'</center>'

                                if "_textarea" in socket_dict:
                                        del socket_dict["_textarea"]
                                if socket_dict:
                                        doc_string = json.dumps(socket_dict)
                                        sock.sendto(doc_string,(UDP_IP,UDP_PORT))
                        else:
                                socket_dict["_textarea"] = this_text
                                if socket_dict:
                                        doc_string = json.dumps(socket_dict)
                                        sock.sendto(doc_string,(UDP_IP,UDP_PORT))
                                total_string += this_text
                except:
                        if not process.is_alive():

                                return total_string

                time.sleep(0.01)
        else:
                return total_string

        return total_string

   def read_file(self,filename,dvar,this_pass):

        #try:
        if True:
                data = [] ; error = []
                data_file = open(filename,'r').readlines()
                nl = len(data_file)

		this_line = 0
                for i in xrange(nl):
                        lin = string.split(data_file[i])

                        if(lin[0] != '#'):
				if this_line > 0 and this_pass == 2:
                                	this_x = lin[dvar[0]]
	                                this_y = lin[dvar[1]]
	                                data.append([this_x,this_y])
				elif this_pass == 1:
                                	this_x = lin[dvar[0]]
	                                this_y = lin[dvar[1]]
	                                data.append([this_x,this_y])
      				this_line += 1	

                if(this_pass == 1):

                        this_data = {
                                        'lines' : { "show": "false" },
                                        'points' : { "show" : "true", "radius" : "4" },
                                        'color' : 'red',
                                        'label' : 'all structures',
                                        'data': data
                                }
                        self.flot_data["data"].append(this_data)

                else:
                        this_data = {
                                        'lines' : { "show": "true", "lineWidth" : "3.0" },
                                        'points' : { "show" : "true", "radius" : "2" },
                                        'color' : 'green',
                                        'label' : 'accepted structures',
                                        'data': data
                                }
                        self.flot_data["data"].append(this_data)



        else: 
        #except:
        #        print 'ERROR READING PLOT DATA FILE'
        #        print 'ERROR READING PLOT DATA FILE'
        #        print 'ERROR READING PLOT DATA FILE'
                self.flot_data = "error reading file and making plot"

        return

   def get_data_from_disk(self,file1,file2):
	
        self.flot_data = {
                                        "options": {
                                                "title"  : "Rg Results",
                                                "xlabel"  : "Structure Number",
                                                "ylabel"  : "Rg (Angstrom)",

                                                "legend": {
# "position" can be "ne" or "nw" or "se" or "sw"
                                                        "position"           : "ne"
# add a margin by number of pixels
                                                        ,"margin"            : 5
# "backgroundOpacity" is a number between 0 and 1
                                                        ,"backgroundOpacity" : 0.7
# "container" puts the legend to the right of the plot
                                                        ,"container"         : "false"
# "sorted" orders the legend entries can be "ascending" or "descending"
                                                        ,"sorted"            : "ascending"
                                                }

                                        },

                                        "data": []
                        }

        dvar=[0,1]
        self.read_file(file1,dvar,1)
        dvar=[2,1]
        self.read_file(file2,dvar,2)

        return 

   def convert_residue_ranges(self,original_reslow,**kwargs):

        r = string.split(original_reslow,',')
        number_of_pairs = 0
	align_flag = False
	if 'seg' in kwargs:
		align_flag = True

        lowres = ''; numcont = ''
        for pair in r:
                this_pair = string.split(pair,'-')
		if not align_flag:
                	lowres += this_pair[0]+','
                	numcont += (str(locale.atoi(this_pair[1]) - locale.atoi(this_pair[0])))+','
		elif align_flag:
                	lowres += str(this_pair[0])+','
                	numcont += str(this_pair[1])+','
                number_of_pairs += 1

        lowres = lowres[:-1]
        numcont = numcont[:-1]

        print 'lowres (convert_residue) = ',lowres
        print 'numcont (convert_residue) = ',numcont

        return lowres, numcont

   def run_me(self,json_flag,json_variables,input_string):

	output_dict = {}

	if not json_flag:

        	#### BEGIN USER EDIT
        	#### BEGIN USER EDIT
        	#### BEGIN USER EDIT

        	runname='run_0'
		dcdfile='run_0.dcd'
		path=''
		pdbfile='fram601.pdb'
		trials='10'
		goback='10'
		temp='300.0'
		nsegments='2'
		segbasis='CA, CA'
		npsegments='2'
		flpsegname='ENDA, ENDB'
		seglow='95, 95'
		seghigh='110, 110'
		lowrg='20.0'
		highrg='185.0'
		zflag='0'
		zcutoff='0.0'
		cflag='0'
		confile = 'constraints.txt'
		plotflag = '0'
		directedmc = '0'
		seed = '0,123'        

		allsnumranges = ["2","2"]
		allsith = ["30.0, 30.0"]
		allsrlow = ["123,277","123,277"]
		allsrnum = ["21,5","21,5"]
		allmoltype = ["protein","protein"]

		psegvariables = []
		for i in xrange(len(allsnumranges)):
			psegvariables.append([allsnumranges[i],allsith[i],allsrlow[i],allsrnum[i],allmoltype[i]])	

        	path='./'

        	#### END USER EDIT
        	#### END USER EDIT
        	#### END USER EDIT
       	else:
		runname = json_variables['runname']

                base_directory = json_variables['_base_directory']

                path = base_directory.replace('\/','/') + "/"

                os.chdir(path)
		data_path = path
                path = ''

                pdbfile = json_variables['pdbfile'][0]
                #head, pdbfile = os.path.split(temp_pdbfile[0])

		dcdfile = json_variables['dcdfile']
		trials = json_variables['trials']
		goback = json_variables['goback']
		temp = json_variables['temp']
		nsegments = json_variables['nsegments']
		npsegments = json_variables['npsegments']

                overlap_list_box = json_variables['overlap_list_box']

                if(overlap_list_box == "c1"):
                        segbasis = 'heavy'
                        cutoff = '0.8'
                elif(overlap_list_box == "c2"):
                        segbasis = 'all'
                        cutoff = '0.8'
                elif(overlap_list_box == "c3"):
                        segbasis = 'backbone'
                        cutoff = '1.0'
                elif(overlap_list_box == "c4"):
                        segbasis = json_variables['basis']
                        cutoff = json_variables['cutoff']
 
		try:
			advanced_input = json_variables['advanced_input']
		except:
			advanced_input = 'off'

		if(advanced_input == "on"):
		
 			#basis = json_variables['basis']
 			#cutoff = json_variables['cutoff']
			lowrg = json_variables['lowrg']
 			highrg = json_variables['highrg']
		
                        try:
                                zflag_check_box = json_variables['zflag_check_box']
                        except:
                                zflag_check_box = "off"
	
			try:
				cflag_list_box = json_variables['cflag_list_box']
			except:
				cflag_list_box = 'off'
 			#plotflag_list_box = json_variables['plotflag_list_box']
 			plotflag_list_box = "c1"

 			directedmc = json_variables['directedmc']

		else:
 			#basis = 'CA'
 			#cutoff = '3.0'
			lowrg = "0.0"
			highrg = "1E9"
			zcutoff = "0.0"
			zflag_check_box = "off"
			cflag_list_box = "off"
 			plotflag_list_box = "c1"
 			directedmc = "0"


                if(zflag_check_box == 'off'):
                        zflag = '0' # NO
                        zcutoff = '0'
                elif(zflag_check_box == 'on'):
                        zflag = '1' # YES
                        zcutoff = json_variables['zcutoff']

                if(cflag_list_box == 'off'):
                        cflag = '0' # NO
			confile = 'constraints.txt'
                elif(cflag_list_box == 'on'):
                        cflag = '1' # YES
			confile = json_variables['confile'][0]
			#head, confile = os.path.split(temp_confile[0])
                if(plotflag_list_box == 'c1'):
                        plotflag = '0' # NO
                elif(plotflag_list_box == 'c2'):
                        plotflag = '1' # YES

		all_seg_low = ''
		all_seg_high = ''
		flpsegname = ''

		psegvariables = []
		for i in xrange(locale.atoi(npsegments)):
			mtype = "protein"
			if(json_variables['moltype'][i] == "c3"):
				mtype = "dna"
			elif(json_variables['moltype'][i] == "c2"):
				mtype = "rna"
			elif(json_variables['moltype'][i] == "c1"):
				mtype = "protein"
		
			#try:
			if True:
				original_flpsegname = str(json_variables['flpsegname'][i])
				flpsegname += original_flpsegname + ','
				original_seg_align = json_variables['seg_align'][i]
				original_srlow = json_variables['srlow'][i]
                		srlow, srnum = self.convert_residue_ranges(original_srlow)
                		seglow, seghigh = self.convert_residue_ranges(original_seg_align,seg=True)
				all_seg_low += seglow + ','
				all_seg_high += seghigh + ','
         		else:
         		#except:
                		error = 'unable to parse residue range for flexible regions: check your input values\n'
                		error += 'it should consist of a pair of hyphenated integers separated by commas\n'
                		error += 'the number of pairs should equal the number of flexible regions'
                		self.message_box(error,'warning.png')
                		output_dict['error'] = error
                		output_dict['sasoutput2'] = 'run failed'
                		print json.dumps( output_dict )
                		return
	
			psegvariables.append([json_variables['numranges'][i].encode('utf8'), json_variables['sith'][i].encode('utf8'), srlow.encode('utf8'), srnum.encode('utf8'), mtype]);

			#psegvariables.append([json_variables['numranges'][i].encode('utf8'), json_variables['sith'][i].encode('utf8'), json_variables['srlow'][i].encode('utf8'), json_variables['srnum'][i].encode('utf8'), mtype]);

		flpsegname = flpsegname[0:-1]
		all_seg_low = all_seg_low[0:-1]
		all_seg_high = all_seg_high[0:-1]

	print 'asl = ',all_seg_low
	print 'ash = ',all_seg_high

	plotflag = '0'

	svariables={}

	svariables['runname'] = (str(runname),'string')

 	svariables['dcdfile']		= (str(dcdfile),'string')
 	svariables['path']		= (str(path),'string')
 	svariables['pdbfile']		= (str(pdbfile),'string')
 	svariables['trials']		= (str(trials),'int')
 	svariables['goback']		= (str(goback),'int')
 	svariables['temp']		= (str(temp),'float')

 	svariables['nsegments']		= (str(nsegments),'int')
 	svariables['segbasis']		= (str(segbasis),'string')
 	svariables['npsegments']	= (str(npsegments),'int')
 	svariables['flpsegname']	= (str(flpsegname),'string')
 	svariables['seglow']		= (str(all_seg_low),'int_array')
 	svariables['seghigh']		= (str(all_seg_high),'int_array')

 	svariables['lowrg']		= (str(lowrg),'float')
 	svariables['highrg']		= (str(highrg),'float')

 	svariables['zflag']		= (str(zflag),'int')
 	svariables['zcutoff']		= (str(zcutoff),'float')
 	svariables['cflag']		= (str(cflag),'int')
 	svariables['confile']		= (str(confile),'string')
 	svariables['plotflag']		= (str(plotflag),'int')
 	svariables['directedmc']        = (str(directedmc),'float')
 	svariables['seed']		= ('0,123', 'int_array') # set this to '1,123' if you want to set the seed or '0,123' if not

	error = []

 	error,self.variables=input_filter.type_check_and_convert(svariables)

        if(len(error)>0):

                self.message_box(error,'skull.png')
#               warning.png, information.png, skull.png, toast.png

                output_dict['error'] = 'Error in input variables'
                output_dict['sasoutput2'] = 'run failed'
                print json.dumps( output_dict )
                return
        else:
		monflag = '1' ; eflag = 0
	
		error=complex_filter.check_complex(self.variables,psegvariables,eflag,monflag,no_file_check="true")

                if(len(error) != 0):
                        self.message_box(error,'warning.png')
                        output_dict['error'] = 'Error in complex variables'
                        output_dict['sasoutput2'] = 'run failed'
                        print json.dumps( output_dict )
                        return

		else:
			runname=self.variables['runname'][0]

			if os.path.exists(runname+'/'+self.module):
				shutil.rmtree(runname+'/'+self.module)

			#with open("/share/apps/genapp/sassie2/results/log","w") as outfile:
			#	json.dump("\nsself.variables\n",outfile)
			#	json.dump(svariables,outfile)
			#	json.dump("\npsegvariables\n",outfile)
			#	json.dump(psegvariables,outfile)
#
			txtQueue=multiprocessing.JoinableQueue()
			process=multiprocessing.Process(target=nmer_dihedral.dihedralgenerate,args=(self.variables,psegvariables,txtQueue))
			process.start()

                        total_string = self.background_job(process,txtQueue,json_variables)

			#output_dict['sasoutput2'] = total_string

			accepted_rg_file = data_path+runname+'/complex_monte_carlo/'+dcdfile+'.accepted_rg_results_data.txt'
			all_rg_file = data_path+runname+'/complex_monte_carlo/'+dcdfile+'.all_rg_results_data.txt'

			self.get_data_from_disk(all_rg_file,accepted_rg_file)

			if(isinstance(self.flot_data, basestring)):
				print 'error reading data'
				output_dict['plot_error'] = self.flot_data
			else:
				output_dict['plotout4'] = self.flot_data

        if output_dict:
                print json.dumps( output_dict )
        else:
                error_string = 'Exception encountered executing '+self.module+' program: please submit feedback and attach run log'
                output_dict['error'] = error_string
                print json.dumps( output_dict )
		
if __name__=='__main__':

	json_flag = True
	#json_flag = False

	if (len(sys.argv) < 1):
		print "\{\"error\":\"complex monte carlo called with no arguments\"\}\n";
# 		print 'exiting now'

	elif len(sys.argv) > 1:
                json_variables = " "
                if(json_flag):
                        argv_io_string = StringIO(sys.argv[1])
                        json_variables = json.load(argv_io_string)
		a=CGenerate_Drv()
                a.run_me(json_flag,json_variables,sys.argv[1])


